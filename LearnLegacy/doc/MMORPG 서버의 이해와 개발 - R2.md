# MMORPG 서버의 이해와 개발 

## 개요 

MMORPG는 게임으로서 매우 다양한 시스템을 갖고 있고 방대한 컨텐츠로 구성됩니다. 또, 많은 사용자들을 하나의 공간이나 
분할된 공간에서 처리할 수 있는 기반을 잘 갖춰야 합니다. 

이 두 가지 측면이 MMORPG를 다른 여타의 게임 서버보다 더 견고하고 빠르며 디버깅이 쉽고 유지보수가 수월하도록 
만들어야만 한다는 과제가 훨씬 중요하도록 합니다. 

당연하게도 모든 게임은 영속성을 갖춰야 합니다. 게임 플레이 중에 발생한 다양한 데이터들을 저장하여 중요 데이터를 
잃어 버리지 않고 유지해야 하며 오류가 없도록 해야 합니다. MMORPG에서 아이템을 포함한 게임 데이터는 긴 시간 플레이 한 
결과물이기 때문에 다른 게임보다 훨씬 더 중요하다고 할 수 있습니다. 

- MMORPG는 기술적인 측면에서 대규모 사용자를 수용하는 실시간 반응형 분산 시스템
- MMORPG는 게임 측면에서 다양한 시스템과 엔티티를 갖춘 영속적인 월드
- MMORPG는 시스템과 엔티티를 풍부하게 만드는 다양한 컨텐츠를 포함 

### MMORPG는 실시간 반응형 분산 시스템

`실시간`은 일정 시간 내 반응을 해야 한다는 뜻입니다. 예를 들어, 스킬을 시전하면 일정 시간 내 반응해야 하고 
데미지 표시가 없는 게임도 있지만 적어도 히트 반응 등은 있어야 합니다. 

`반응형`이란 뜻은 사용자의 입력과 시간에 반응한다는 뜻입니다. 사용자의 입력은 패킷으로 서버에 전달되므로 
서버 입장에서는 패킷에 반응하여 처리하고, 설정된 시간 (타이머)에 따라 동작한다는 뜻입니다. 

`분산` 시스템이란 뜻은 데이터베이스나 레디스, 게임에 따라 월드 서버와 게임 서버 등 역할에 따라 여러 장비에 
걸친 프로세스들 간의 통신을 통해 처리한다는 뜻입니다. 

이 세 가지 요소를 잘 만족할 수 있도록 서버 아키텍처를 설계하고 구현해야 합니다. 그리고, 이미 구현된 게임 서버라면 
이를 구현한 구조를 파악하고 잘 사용할 수 있어야 합니다. 

### MMORPG는 다양한 시스템과 엔티티를 갖춘 영속적인 월드 

다양한 `시스템`을 갖춘 월드라는 뜻은 다양한 상태들을 나누고 이들 상태들을 적절한 조건에 따라 다시 변경해 나갈 수 
있도록 논리적으로 분할된 여러 기능을 갖고 있다는 뜻입니다. 전투 `시스템`이라고 하면 월드 내 엔티티들 간에 
피아 관계의 설정, 스킬의 보유와 사용 조건, 스킬의 시전과 피격 판정, 피격 엔티티에 대한 데미지 적용 등의 
상태에 적용되는 규칙들의 모음이라고 할 수 있습니다. 

코드 상에 `시스템`으로 주어진 이름이 없더라도 이와 같이 상태와 기능의 논리적인 분할 단위로 `시스템`을 생각할 수 있고 
기획 단에서 이와 같이 명시적으로 전투 `시스템`으로 명명하는 경우도 있고 그렇지 않은 경우도 있으나 
개념 상으로는 있다고 생각하면 좋을 듯 합니다. 

`시스템`은 상태와 조건에 따른 변화를 규정하는 분리된 단위라고 다시 씁니다. 단지, 하나의 상태가 여러 `시스템`에서 동시에 
사용될 수도 있으므로 상태까지 완전히 분리되지는 않습니다. 

`엔티티`는 다른 것들과 분리 가능한 어떤 존재라고 볼 수 있고, 게임 서버에서는 능동적인 행동을 하며 `시스템`이나 다른 
`엔티티`와 상호 작용하는 객체라고 보통 생각하는 것 같습니다. `엔티티`는 언리얼의 경우 액터라고 불리고, 유니티는 
게임오브젝트라고 합니다. 

`엔티티`는 여러 `시스템`이나 다른 `엔티티`들과 상호작용하므로 이들 작용의 대상에 따라 여러 가지 행동을 갖고 있습니다. 
이들 행동들과 행동을 위한 상태들을 `엔티티` 내에서 분리하여 흔히 `컴포넌트`로 구현하는 경우가 많고 언리얼은 컴포넌트, 
유니티는 MonoBehavior라고 하는 인터페이스를 제공합니다. 

`엔티티`는 이들이 존재하는 공간이나 컨테이너가 필요하고 이를 담고 있는 공간 전체를 `월드`라고 할 수 있습니다. 
`월드`는 잘게 나뉘어 있을 수도 있고 심리스(Seamless)라고 불리는 연속된 공간인 경우도 있습니다. 

`영속적인` 월드는 서버를 다시 시작했을 때 이전과 동일한 (또는 재시작 가능한) 게임 상태를 제공할 수 있어야 한다는 
뜻입니다. 메모리 상에서 게임을 동작하도록 하기위한 상태값 (동적 상태)와 데이터베이스에 저장하여 영속성을 
제공해야 하는 상태 (영속 상태)로 나누어 생각해 볼 수 있습니다. 이는 잃어도 되는 상태와 보존해야 하는 상태로 
나누어 생각하는 것과 같습니다. 

### MMORPG는 시스템과 엔티티를 풍부하게 만드는 다양한 컨텐츠를 포함 

시스템과 엔티티로 구성된 규칙 기반의 논리적인 월드는 실제 `데이터`와 `애셋`으로 풍부한 컨텐츠로 만들어집니다. 

규칙과 내용으로 분리하여 생각하여 정의된 컨텐츠는 다른 문맥에서는 다르게 불리기도 하므로 
어떤 문맥에서 사용되는지 고려하여 이해해야 하고, 여기서는 규칙의 내용을 규정하는 `데이터`와 `에셋`이란 
의미로 사용합니다. 

`애셋`은 그래픽 데이터를 가리키는 용어로 사용합니다. 클라이언트에서 표현되는 캐릭터, 아이템, 애니메이션, 이펙트, 
레벨, 레벨 내 오브젝트들 (매시, 애님, 이펙트 등)을 포괄하는 아트 데이터를 모두 포괄합니다. 

`데이터`는 주로 서버의 시스템과 엔티티의 판단 조건과 행동, 행동에 따른 상태 변화 결과를 결정하는 기획적인 
`데이터`를 말합니다. `데이터`는 주로 엑셀에서 작업하고 csv나 데이터베이스 테이블에 보관하고 서버가 실행될 때 
초기에 로딩하여 각 코드에서 다시 사용합니다. 

서버 설계와 구현에 있어 `데이터`를 어떻게 관리하고 활용하는가는 매우 중요한 설계와 구현 요소입니다. 
프로젝트 전체적으로도 데이터 생성과 관리 과정이 매우 중요한 프로세스입니다. 다르게 표현하면 
게임 서버의 개발은 기획 `데이터`를 실행하는 구조를 개발하는 과정이라고 볼 수도 있습니다. 그 만큼 
중요한 요소이고 잘 협의하여 좋은 구조와 규약을 정리할 필요가 있습니다. 

## 서버 아키텍처

실시간 반응형 분산 시스템으로서 게임 서버를 동작하도록 하기위해 여러 가지 선택들을 하게 됩니다. 이런 선택에 
따라 게임 서버 구조는 매우 다르고 실제 월드를 만들기 위한 시스템과 엔티티의 설계와 구현도 여기에 깊게 의존합니다. 

### 상태 공유 멀티 쓰레딩 

R2가 선택한 가장 중요한 결정은 상태 공유 멀티 쓰레딩(Shared state multithreading)입니다. 상태 공유 멀티 쓰레딩은 
게임 서버 프로세스에서 여러 쓰레드들이 같은 코드로 공유된 데이터에 접근할 수 있도록 설계되고 구현되었다는 
뜻입니다. 실질적으로는 IOCP 쓰레드에서 락을 사용하여 여러 쓰레드에서 안전하게 접근하면서 처리되도록 한다는 뜻입니다. 

IOCP 쓰레드는 통신 처리와 타이머에서 받은 이벤트를 함께 처리하도록 되어 있습니다. 

#### 락 규약 

락 종류, 락을 거는 지점에 대해 일정한 규약이 없으면 매번 판단해야되기 때문에 어렵고 코드를 이해할 때에도 
매번 다르다면 어디에서 거는지 찾아야 하고 정확한지도 확신하기 어렵습니다. 따라서, 대부분의 서버에서 
일정한 규약을 갖고 락을 거는 지점과 락 종류를 결정하여 이를 따르도록 합니다. 

이들 락 사용에 관한 규약은 문서화되지 않았을 수도 있고 사람마다 미묘한 사용의 차이가 있을 수 있어 
오래 라이브 개발을 진행했던 분들께 문의하고 코드에서 파악하여 정리해 두면 좋을 듯 합니다. 

### 반응 처리 구조 

실시간 반응형 분산 시스템으로서의 게임 서버에서 반응형에 해당하는 부분입니다. 반응은 패킷과 시간(타이머)로 
이루어지므로 이를 처리하는 구조가 반응 처리 구조입니다. 

R2 서버에서 패킷 처리를 담당하는 클래스를 Troc(Transaction Procedure)라고 합니다. Transaction만 처리하는 것은 
아니므로 정확한 이름은 아니라고 생각할 수도 있지만 상태를 변경하는 트랜잭션이라는 관점으로 보면 
상태 공유 멀티 쓰레딩 하에서 동작하므로 전체적으로 트랜잭션으로 동작하는 서버 구조로 초기 설계자가 결졍했다고 
이해할 수 있습니다. 

시간에 대한 반응 처리는 타이머로 이루어집니다. 세부 사항은 코드로 살펴봐야 하지만 기본 개념은 타이머도 패킷과 
동일한 이벤트로 발생을 시켜 여러 쓰레드에서 실행하는 형태로 되어 있습니다. 전용 Troc을 걸쳐 실행되는 흐름을 
갖기 때문에 결국 반응 처리는 Troc으로 시작 지점이 단일화 / 개념화 되어 있습니다. 

### 월드별 단일 게임 서버 

R2는 단일 게임 서버를 사용하는 방식을 분산 구조로 선택했습니다. 월드 서버와 게임 서버를 월드별로 두는 구조도 
많이 사용하는 방식이나 분산 처리에서 발생하는 어려움을 덜고 간결한 구조를 만들기위해 여러 코어 (32코어 이상)의 
서버에서 전체 월드의 시스템과 엔티티를 실행하는 구조를 택했습니다. 

이는 상태 공유 멀티 쓰레딩이 역할별 쓰레드 구조보다 동시성을 높일 수 있다는 것이 가장 큰 장점이기에 
가능한 선택이기도 합니다. 

분산은 데이터베이스와 외부 연동 서버 위주로 이루어지고, 이는 R2의 모바일 후속작인 R2M에서도 지속되는 구조입니다. 

### 데이터베이스 처리 

데이터베이스 처리도 기본적으로는 반응 처리 쓰레드에서 처리합니다. 패킷이나 타이머 이벤트에서 게임을 실행하는 
쓰레드 내에서 데이터베이스 처리도 함께 이루어집니다. 

DB 처리 동안에도 락 처리가 이루어져야 합니다. 최소한 읽기 락은 걸어야 합니다. 이는 중요한 락 규약 중의 
하나가 됩니다. 

R2에서 DB API는 ODBC에 기반하여 이를 안정적이고 쉽게 사용하기 위한 wrapper를 정의하여 사용하고 있습니다. 
CSql로 시작하는 여러 클래스들이 있고 여기서 Open()에서 Prepare()하고 SelectPcQuest()와 같은 함수들에서 
조회, 업데이트, 삭제, 추가 등을 하는 걸 확인할 수 있습니다. 

R2는 Stored Procedure를 함께 사용합니다. SQL 서버 SP들을 하나씩 살펴보고 현재 규약들, 사용한 방식에서 
일정한 패턴을 이해하고 필요할 때 수정하거나 추가하면서 연습하면 될 듯 합니다. 

## 데이터 관리 구조 

R2의 기획 데이터는 Parm (Parameter, 팜)로 불리며 CSqlParm*로 된 클래스들에서 개별 데이터를 DB에서 로딩하고
CParam\*Mgr 클래스들에서 이를 사용하여 전체 테이블을 로딩하고 접근 시 조건 체크 등을 하면서 
사용할 수 있는 인터페이스를 제공합니다. 

CParmItem 등과 같이 기본 바탕이 되는 여러 CParm들이 FnlApp 프로젝트에 정의되어 있습니다. 

## 게임 사전의 관리 (제안) 

게임 서버의 코드에서 사용하는 용어와 기획자들, 사용자들이 부르는 단어가 다를 수 있습니다. 
Item과 같이 명확한 것도 있겠으나 CParmModule이나 CParmSlain 같은 것은 다를 수도 있습니다. 
또한, 규칙에 해당하는 용어도 다를 수 있습니다. 

이들을 엑셀 파일이나 다른 편리한 파일을 사용하여 정리해 두면 코드를 이해하고 구현하는데 
많은 도움이 될 수 있습니다. 아마도 엑셀 파일을 공유해 두고 같이 관리해 나가는 것이 
가장 편리하고 손쉬운 방법으로 보입니다. 

예를 들어, DDv, MDv, RDv, DPv 등등도 이런 파일에 설명해 두고 기획, 사용자 용어를 함께 
적어두면 좋을 듯 합니다. 

이들 사전은 시스템과 엔티티, Parm의 오브젝트와 필드 이해에 큰 도움이 될 듯 합니다. 

## 시스템과 엔티티 

팜(Parm)에 정의되고 DB 테이블에 보관된 데이터에 따라 실행하는 기계를 만드는 작업이 서버를 만드는 것이라고 
볼 수 있습니다. 위에서 언급한 

> 게임 서버의 개발은 기획 `데이터`를 실행하는 구조를 개발하는 과정이라고 볼 수도 있습니다

와  유사한 얘기로 생각할 수 있습니다. 

R2의 게임 엔티티들은 CChar와 이를 상속한 CPc와 CMonster가 있습니다. 몇 가지 CChar를 상속받은 클래스들이 
더 있으나 CChar, CMonster, CPc가 가장 중요한 엔티티들입니다. 

R2에서 하나의 시스템은 해당 기능을 시작하는 Troc, 상태와 연관된 오브젝트를 관리하는 Mgr(매니저)들, 
Mgr들에서 필요하거나 Troc들에서 필요한 상태를 갖고 있는 CChar와 하위 클래스들, 또 규칙이나 조건/보상을 
규정하는 CParm 클래스들로 구성됩니다. 

CChar(CPc, CMonster)내의 기능은 함수들로 잘 분리하려고 노력이 많이 들어가 있으나 아무래도 컴포넌트 없이 
하나의 클래스에 상속만으로 분리하다 보니 어느 정도 한계가 있는 부분이고 잘 파악하고 정리하고 
관리해야 하는 부분 중 하나일 듯 합니다. 

## 코드 분석 

지금까지 적은 내용은 직접 라이브 개발을 해보지 않고 문제 해결 지원 과정이나 통신과 처리 엔진 포팅 등에서 
얻은 경험, R2M 지원 과정에서 이해한 내용들에 기초하여 정리한 내용입니다. 

라이브 개발을 하지는 않았기에 구체적인 클래스들, 게임 시스템들에 대해서 정리하기는 어려운 점이 있어 
일반적인 코드 분석에 대해 얘기하고 관련된 도구 사용을 지원하려고 합니다. 

### doxygen

doxygen은 코드 내에 작성된 주석을 활용하여 코드를 문서화 하는 도구입니다. 

doxygen 자체의 발전이 많이 있었고 중요한 도구 중의 하나이다. doxygen으로 문서를 생성하고 주석과 함께 생성된 
문서로 구조를 살펴보는 과정 자체가 중요한 리뷰와 이해과정입니다. 

doxygen은 자체의 파서와 그래프 툴이 있다. 파서는 에러를 잘 견딜 수 있게 개발되어 빌드 되지 않는 코드에 대한 
문서화가 가능합니다.  

이 외에 초기에 전체 구조를 파악하는데 큰 도움이 될 수 있습니다. 전체 클래스 목록, 파일 목록을 파악하기 쉽고 
호출/호출자 그래프로 실행하지 않은 상태에서 코드 흐름을 파악할 수 있습니다. 또 링크를 생성해 주므로 오가면서 
보기에도 괜찮은 편입니다. 

### 실행 분석 

빌드가 되면 클라이언트를 사용하여 서버의 Troc에서 시작되는 패킷 처리 흐름을 파악하면서 연관된 클래스 
구조와 호출 관계, 중요 함수의 상태 변경 내용, 데이터베이스 저장 등을 파악해야 합니다. 

이 과정이 코드 분석의 핵심이며 읽기만 해서는 어려운 여러 가지 코드의 세부를 파악 가능하게 해줍니다. 

doxygen에서 생성한 호출 관계, 함수 등과 비교하면서 읽으면 더 도움이 될 듯 합니다. 

중요 Troc들의 호출 흐름과 상태 변경 내용을 묶어서 정리하면 좋을 듯 하다. UML의 시퀀스 다이어그램을 
그려 보는 것도 이해를 위한 중요한 수단 중 하나입니다. 아래 시스템과 연관 엔티티의 개념화를 위한 
수단 중 하나이기도 합니다. 

### 시스템과 연관 엔티티의 개념화 

독립된 기능 단위로서 시스템이 여러 클래스들에 걸쳐서 구현되므로 시스템을 찾아내는 과정을 통해 
개념화 하고 엔티티(특히, CPc)의 함수들을 기능 단위로 나눠서 시스템의 기능으로 분리해서 
하나로 정리해 두면 좋을 듯 합니다. 

- 캐릭터 시스템 
  - 캐릭터 생성, 삭제
  - 캐릭터 스텟 
  - 캐릭터 레벨업 
  - 캐릭터 사망과 부활 
- 인벤토리 시스템 
- 아이템 드랍 시스템 
- 아이템 루팅 시스템 
- 아이템 강화 시스템 
- 아이템 상점 시스템 
- 퀘스트 시스템 
- 필드/던전 시스템 / 포털 시스템 
- ...... 

위와 같은 단위로 같이 협의해서 시스템으로 이름 짓고 연관된 Troc (패킷, 타이머), DB 테이블, Parm, 매니저, 
매니저의 관리 대상 클래스, 엔티티들의 연관 함수 등을 정리해 나갈 수 있을 듯 합니다. 

이들 시스템 별로 doxygen 결과물을 포함핟여 간단하게라도 정리해 보면 기능을 이해하고 개발을 효율적으로 
진행하는데 많은 도움이 되리라 믿습니다. 


### 코딩 스타일 가이드 정리 

코딩 스타일 가이드는 코딩 컨벤션 또는 코딩 규약이라고도 하고 일관되게 지켜서 오래 되어도 
마치 한 사람이 작성한 듯한 코드로 유지되어야 가독성과 작업 효율을 올릴 수 있습니다. 

여러 사람이 오래 개발한 R2 서버는 비교적 코딩 스타일이 일관되게 유지되고 좋은 스타일을 갖고 있는 편입니다. 
특히, 에러 처리를 위한 aRv 값과 체크하여 0일 경우 정상이고 그렇지 않을 경우 에러 처리를 하도록 정의되어 있습니다. 
또한 FNL_ASSERT로 사전 조건(precondition)을 꼼꼼하게 체크하고 널 포인터를 포함한 다른 사전 조건 체크들도 
잘 정리되어 있습니다. 

명명 규칙을 포함하여 기존에 작성된 코드와 일치하도록 스타일을 정리하여 익숙해지도록 하는 것이 필요합니다. 

